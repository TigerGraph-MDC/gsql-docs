= Query User-Defined Functions
:pp: {plus}{plus}

In GSQL, users can supplement the language by defining their own query user-defined functions (query UDF) in C{pp}. Query UDFs can be called in queries and subqueries to perform a set of defined actions and return a value like the built-in functions.

This page introduces the process to define a query UDF. Once defined, the new functions are added into GSQL automatically the next time GSQL is executed.

Query UDFs are user-editable in the form of an `.hpp` file locally on your machine. These get uploaded and interpreted by the server through a GSQL command. Creating, editing, or removing Query UDFs is done by downloading them from the server, editing the file, and reuploading.

== Define a query UDF

Below are the steps to add a Query UDF to GSQL:

=== Step 1: Download current query UDF file

Use the `GET ExprFunctions` command in GSQL to download the current list of functions into a local file. The path is not important (as you will be reuploading them later) but the file extension must be `.hpp`:

[source,gsql]
----
GSQL > GET ExprFunctions TO "/example/path/to/ExprFunctions.hpp"
----

If your query UDF requires a user-defined struct or helper function, also use the `GET ExprUtil` command to download the current `ExprUtil` file:

[source,gsql]
----
GSQL > GET ExprUtil TO "/example/path/ExprUtil.hpp"
----

=== Step 2: Define C{pp} function

Define the C{pp} function inside the UDF file you just downloaded in Step 1. The definition of the function should include the keyword `inline`.

Only `bool`, `int`, `float`, `double`, and `string` (NOT `std::string`) are allowed as function arguments or returns. Any C{pp} data type is allowed inside a function body.

.Allowed Data Types
|===
|Data Type | Argument | Return | Function Body
| `bool` | Yes | Yes | Yes
| `int` | Yes | Yes | Yes
| `float` | Yes | Yes | Yes
| `double` | Yes | Yes | Yes
| `string` | Yes | Yes | Yes
| `std::string` | *No* | *No* | Yes
| xref:accumulators.adoc[Accumulators] | Yes | Yes | Yes

| All other C{pp} data types | *No* | *No* | Yes
|===

If the function requires a user-defined struct or helper function, define it in the `ExprUtil` file you downloaded in Step 1.

Below is an example of a query UDF definition that includes two separate functions. The first function returns `true` if the passed value is greater than 3, and the second reverses a string.

.New code in ExprFunctions.hpp

[source,c++]
----
#include <algorithm>  // for std::reverse
inline bool greater_than_three (double x) {
  return x > 3;
}

inline string reverse(string str){
  std::reverse(str.begin(), str.end());
  return str;
}
----



[CAUTION]
====
If any code in `ExprFunctions.hpp` or `ExprUtil.hpp` causes a compilation error, GSQL will be unable to install _any_ new queries, whether user-defined or not.
====

.test.cpp

[source,gsql]
----
#include "ExprFunctions.hpp"
#include <iostream>
int main () {
  std::cout << to_string (123) << std::endl;    // to_string and str_to_int are two built-in functions in ExprFunction.hpp
  std::cout << str_to_int ("123") << std::endl;
  return 0;
}
----

=== Step 3: Upload files

After you have defined the function, use the `PUT` command to upload the files you modified.

[source,gsql]
----
GSQL > PUT ExprFunctions FROM "/path/to/udf_file.hpp"
PUT ExprFunctions successfully.
GSQL > PUT ExprUtil FROM "/path/to/utils_file.hpp"
PUT ExprUtil successfully.
----

The `PUT` command will automatically upload the files to all nodes in a cluster, overwriting any existing files that contain UDFs. Once the files are uploaded, you will be able to call the query UDF the next time GSQL is executed. This includes the next time you start the GSQL shell or executing GSQL scripts from a bash shell.

.Example of a GSQL query that uses the UDF

[source,gsql]
----
CREATE QUERY udfExample() FOR GRAPH minimalNet {
  DOUBLE x;
  BOOL y;

  x = 3.5;
  PRINT greater_than_three(x);
  y = greater_than_three(2.5);
  PRINT y;

  PRINT reverse("abc");
}
----



== Example

Suppose you are working in a distributed environment and want to add a function `rng()` that that returns a random double between 0 and 1.

Start by downloading the current UDF file with the `GET` command. Here the file name is `udf.hpp` in contrast to above, where it was named `ExprFunctions.hpp`. Only the file contents and extension are important, not the name.

[source,gsql]
----
GSQL > GET ExprFunctions TO "/home/tigergraph/documents/udf.hpp"
----

In the downloaded file, add the function definition for the `rng()` function and add the necessary include directives at the top:

.udf.hpp

[source,c++]
----
// Some code is left out for simplicity

// Copyright (c) 2015-2021, TigerGraph Inc.

#ifndef EXPRFUNCTIONS_HPP_
#define EXPRFUNCTIONS_HPP_

#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <gle/engine/cpplib/headers.hpp>
#include <iostream>
#include <fstream>
#include <sstream>
#include <random> // include statement for rng()
#include <vector>
#include <map>

#include "ExprUtil.hpp"

  // other UDFs ...

  inline double rng() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution < double > distribution(0.0, 1.0);

    return distribution(gen);
  }

  // other UDFs ...

#endif /* EXPRFUNCTIONS_HPP_ */
----

After adding your query, use the `PUT` command to upload the file. This will upload the file to all nodes in a cluster:

[source,gsql]
----
GSQL > PUT ExprFunction FROM "/path/to/udf.hpp"
PUT ExprFunctions successfully.
----

The UDF has now been added to GSQL. You can `INSTALL` and `RUN` the function in GSQL queries.

[source,gsql]
----
GSQL > RUN QUERY rng()
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [{"rng()": 0.51352}]
}
----
